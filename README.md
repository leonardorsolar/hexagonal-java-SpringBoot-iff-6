Claro! Aqui est√° sua **terceira etapa** revisada com mais clareza, fluidez e padroniza√ß√£o:

---

# Tutorial Arquitetura Hexagonal - CRUD de Usu√°rios | API + MongoDB (NoSQL) + Kafka (Mensageria)

Aprenda na pr√°tica como aplicar a **Arquitetura Hexagonal** em microsservi√ßos utilizando **Java**, **Spring Boot**, **MongoDB** e **Kafka**.

Neste projeto, construiremos um **CRUD de Clientes**, explorando todas as camadas da arquitetura de forma clara e orientada.

---

## üîÅ Etapa 5: Camada de _Infrastructure_ ‚Äî Cria√ß√£o do Adaptador _Repository_

Ap√≥s modelarmos as classes de dom√≠nio `Customer` e `Address`, o caso de uso `CreateCustomerUseCase` e o adaptador de sa√≠da `AddressLookupOutputPort` para buscar o CEP, nosso pr√≥ximo passo √© criar o **adaptador da porta de sa√≠da** respons√°vel por acessar o banco de dados. Esse adaptador ser√° a implementa√ß√£o da interface `CustomerPersistenceOutputPort`.

-   Ser√° feita uma **implementa√ß√£o concreta do reposit√≥rio utilizando MongoDB**. `MongoCustomerRepositoryAdapter`

Esse adaptador ter√° como responsabilidade realizar opera√ß√µes de persist√™ncia e consulta de dados no banco **MongoDB**, conforme definido pelo contrato da interface de sa√≠da.

---

---

√ìtima pergunta! Aqui est√£o os **objetivos da Etapa 5: Cria√ß√£o do Adaptador Repository na camada de Infrastructure**, considerando o uso do MongoDB e os princ√≠pios da arquitetura hexagonal:

---

### üéØ Objetivos da Etapa

-   ‚úÖ **Implementar o adaptador da porta de sa√≠da `CustomerPersistenceOutputPort`**, criando a classe `MongoCustomerRepositoryAdapter` respons√°vel por interagir com o banco de dados MongoDB.

-   ‚úÖ **Garantir o isolamento do dom√≠nio em rela√ß√£o √† tecnologia de persist√™ncia**, mantendo a independ√™ncia da l√≥gica de neg√≥cio em rela√ß√£o ao banco de dados utilizado.

-   ‚úÖ **Facilitar testes e manuten√ß√£o**, permitindo que a persist√™ncia possa ser facilmente substitu√≠da por outra tecnologia (como PostgreSQL, MySQL ou at√© armazenamento em mem√≥ria) sem impactar o dom√≠nio ou os casos de uso.

-   ‚úÖ **Aplicar os princ√≠pios da arquitetura hexagonal**, desacoplando o n√∫cleo da aplica√ß√£o das implementa√ß√µes externas.

-   ‚úÖ **Encapsular a l√≥gica de acesso ao banco de dados**, concentrando as opera√ß√µes de leitura e escrita em um √∫nico componente adaptador, tornando o c√≥digo mais coeso e reutiliz√°vel.

---

Perfeito! Abaixo est√° a vers√£o **ajustada e did√°tica** do tutorial, com explica√ß√µes claras para iniciantes, seguindo a arquitetura hexagonal e usando Spring Boot + MongoDB:

---

## ‚úÖ Configura√ß√£o da Camada de Persist√™ncia com MongoDB (Spring Data)

Vamos configurar o MongoDB como banco de dados para persistir os dados da aplica√ß√£o. Lembre-se: na arquitetura hexagonal, a **infraestrutura (banco de dados)** deve ser acessada apenas por **adaptadores**, e nunca diretamente pelo dom√≠nio ou pelos casos de uso.

---

## ‚úèÔ∏è Parte 1: Configura√ß√£o da URI do MongoDB

Abra o arquivo `application.properties` ou `application.yml` dentro da pasta:

```
src/main/resources/
```

E adicione a URI de conex√£o com o MongoDB:

### Para `application.properties`:

```properties
spring.data.mongodb.uri=mongodb://localhost:27017/hexagonal
```

utilizaremos o de cima do que o arquivo yml

### Para arquivos .yml `application.yml` (alternativa):

```yaml
spring:
    data:
        mongodb:
            uri: mongodb://localhost:27017/hexagonal
```

Essa URI diz ao Spring Boot para se conectar a um banco MongoDB rodando localmente na porta 27017, usando o banco chamado `hexagonal`.

---

## ‚úèÔ∏è Parte 2: Cria√ß√£o das classes **Entity**

> No MongoDB, os dados s√£o armazenados em cole√ß√µes (semelhante a tabelas em bancos relacionais).
> Essas entidades n√£o fazem parte do **dom√≠nio**, pois est√£o ligadas √† forma como os dados s√£o **armazenados**, ou seja, pertencem √† **camada de infraestrutura**.

Crie as entidades dentro do pacote:

```
src/main/java/com/example/hexagonal/infrastructure/adapter/output/repository/entity
```

### `CustomerEntity.java`

```java
package com.example.hexagonal.infrastructure.adapter.output.repository.entity;

import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.mapping.Document;
import lombok.Data;

@Data
@Document(collection = "customers") // Define o nome da cole√ß√£o no MongoDB
public class CustomerEntity {

    @Id
    private String id;

    private String name;

    private AddressEntity address;

    private String cpf;

    private Boolean isValidCpf;
}
```

Claro! Aqui est√° uma explica√ß√£o objetiva e resumida:

---

### üîé O que √© `CustomerEntity.java`?

A classe `CustomerEntity` representa **como o cliente ser√° salvo no MongoDB**.

Ela √© uma **entidade da camada de infraestrutura**, usada apenas para persist√™ncia dos dados.

---

### üß± Detalhes do c√≥digo:

-   `@Document(collection = "customers")`: indica que os dados ser√£o salvos na cole√ß√£o `customers` no MongoDB.
-   `@Id`: define o campo `id` como identificador √∫nico do documento.
-   `AddressEntity`: endere√ßo do cliente, definido como um objeto aninhado.

> üí° Essa classe n√£o deve ser usada no dom√≠nio. Ela √© espec√≠fica para o banco de dados.

Vamos agora criar a classe `AddressEntity.java`

### `AddressEntity.java`

```java
package com.example.hexagonal.infrastructure.adapter.output.repository.entity;

import lombok.Data;

@Data
public class AddressEntity {
    private String street;
    private String city;
    private String state;
}
```

---

## ‚úèÔ∏è Parte 3: Cria√ß√£o da Interface de Reposit√≥rio de mapeamento dos m√©todos de acesso ao MongoDB

O **Spring Data MongoDB** precisa da **interface** para gerar automaticamente os m√©todos de acesso ao banco

### üìÅ Caminho:

```
src/main/java/com/example/hexagonal/infrastructure/adapter/output/repository
```

### üß± Passo 1: Interface de Reposit√≥rio

Essa interface ser√° usada pelo Spring Data para mapear automaticamente os m√©todos de acesso ao MongoDB:

crie o arquivo MongoCustomerRepository.java em src/main/java/com/example/hexagonal/infrastructure/adapter/output/repository

```java
package com.example.hexagonal.infrastructure.adapter.output.repository;

import com.example.hexagonal.infrastructure.adapter.output.repository.entity.CustomerEntity;
import org.springframework.data.mongodb.repository.MongoRepository;

public interface MongoCustomerRepository extends MongoRepository<CustomerEntity, String> {
}
```

---

### üß± Por que criar a `MongoCustomerRepository.java`?

O **Spring Data MongoDB** precisa dessa **interface** para gerar automaticamente os m√©todos de acesso ao banco, como:

-   `save()`
-   `findById()`
-   `deleteById()`
-   `findAll()`

---

### ‚úÖ O que ela faz?

Essa interface **conecta o Spring Boot ao MongoDB**, sem que voc√™ precise escrever consultas manuais.

> Voc√™ s√≥ diz **qual entidade** (no caso, `CustomerEntity`) e o **tipo da chave** (`String`), e o Spring cuida do resto.

---

### üìå Em resumo:

> A `MongoCustomerRepository` √© a ponte que o Spring usa para ler e gravar clientes no MongoDB automaticamente.

# Criando o adapatador da porta de sa√≠da (CustomerPersistenceOutputPort) de inser√ß√£o do cliente

## ‚úèÔ∏è Parte 3: Cria√ß√£o do Adaptador de Sa√≠da no reposit√≥rio

> A camada de aplica√ß√£o j√° possui uma **porta de sa√≠da** chamada `CustomerPersistenceOutputPort`, que define o contrato para salvar o cliente.
> Agora vamos criar sua implementa√ß√£o concreta, que **interage com o MongoDB**, chamada `MongoCustomerRepositoryAdapter`.

### üß± Passo 1: Adaptador `MongoCustomerRepositoryAdapter`

Crie o arquivo MongoCustomerRepositoryAdapter.java em:
src/main/java/com/example/hexagonal/infrastructure/adapter/output/MongoCustomerRepositoryAdapter.java

Agora sim, o **adaptador real** da porta de sa√≠da:

```java
package com.example.hexagonal.infrastructure.adapter.output;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import com.example.hexagonal.application.port.output.CustomerPersistenceOutputPort;
import com.example.hexagonal.domain.Customer;
import com.example.hexagonal.infrastructure.adapter.output.repository.MongoCustomerRepository;
import com.example.hexagonal.infrastructure.adapter.output.repository.entity.CustomerEntity;
import com.example.hexagonal.infrastructure.adapter.output.repository.mapper.CustomerEntityMapper;

// pensar em nomear MongoCreateCustomerRepositoryAdapter
@Component
public class MongoCustomerRepositoryAdapter implements CustomerPersistenceOutputPort {

    @Autowired
    private MongoCustomerRepository repository;

    @Autowired
    private CustomerEntityMapper mapper;

    @Override
    public void save(Customer customer) {
        CustomerEntity entity = mapper.toCustomerEntity(customer);
        repository.save(entity);
    }
}
```

Foi injetados o repositorio para o m√©todo utilizar o repository

@Component para a classe ser gerenciada pelo spring
@Autowired

compare a diferen√ßa de utiliza√ß√£o ou n√£o decorator do spring boot.

```java
@Component
public class MongoCustomerRepositoryAdapter implements CustomerPersistenceOutputPort {

    private final MongoCustomerRepository repository;

    private final CustomerEntityMapper mapper;

    public MongoCustomerRepositoryAdapter(MongoCustomerRepository repository, CustomerEntityMapper mapper) {
        this.repository = repository;
        this.mapper = mapper;
    }

    @Override
    public void save(Customer customer) {
        CustomerEntity entity = mapper.toCustomerEntity(customer);
        repository.save(entity);
    }
}
```

Oberve abaixo:

```java
@Override
    public void save(Customer customer) {
        MongoCustomerRepository.save();

    }
```

Quando criamos o MongoCustomerRepository, criamos as classe de entidades CustomerEntity e AddressEntity
A classe CustomerEntity que ser√° salva na base de dados.
Para que possamos salvar, tereos que criar um mapper para transforma customer em CustomerEntity

```java
 @Override
    public void save(Customer customer) {
        CustomerEntity entity = mapper.toCustomerEntity(customer);
        repository.save(entity);
    }
```

Assim est√° pronto no adapatador de inser√ß√£o de cliente

---

## ‚úÖ Observa√ß√£o sobre o Mapper

Como estamos convertendo entre `Customer` (dom√≠nio) e `CustomerEntity` (infra), √© recomendado criar um **mapper**.

---

## üõ†Ô∏è Crie o arquivo:

`src/main/java/com/example/hexagonal/infrastructure/adapter/output/repository/mapper/CustomerEntityMapper.java`

Usando o Spring boot:

```java
package com.example.hexagonal.infrastructure.adapter.output.repository.mapper;

import com.example.hexagonal.domain.Customer;
import com.example.hexagonal.infrastructure.adapter.output.repository.entity.CustomerEntity;
import org.mapstruct.Mapper;

@Mapper(componentModel = "spring")
public interface CustomerEntityMapper {

    // eu recebo um Customer e retorno um CustomerEntity
    CustomerEntity toCustomerEntity(Customer customer);

}
```

Vamos optar com spring boot, mas veja o sem Spring boot:

```java
package com.example.hexagonal.infrastructure.adapter.output.repository.mapper;

import org.springframework.stereotype.Component;

import com.example.hexagonal.domain.Address;
import com.example.hexagonal.domain.Customer;
import com.example.hexagonal.infrastructure.adapter.output.repository.entity.AddressEntity;
import com.example.hexagonal.infrastructure.adapter.output.repository.entity.CustomerEntity;

@Component
public class CustomerEntityMapper {

    // Dom√≠nio -> Entidade (para salvar no banco)
    public CustomerEntity toEntity(Customer customer) {
        AddressEntity addressEntity = new AddressEntity();
        addressEntity.setStreet(customer.getAddress().getStreet());
        addressEntity.setCity(customer.getAddress().getCity());
        addressEntity.setState(customer.getAddress().getState());

        CustomerEntity entity = new CustomerEntity();
        entity.setId(customer.getId());
        entity.setName(customer.getName());
        entity.setCpf(customer.getCpf());
        entity.setIsValidCpf(customer.getIsValidCpf());
        entity.setAddress(addressEntity);

        return entity;
    }

    // Entidade -> Dom√≠nio (para uso na aplica√ß√£o)
    public Customer toDomain(CustomerEntity entity) {
        Address address = new Address();
        address.setStreet(entity.getAddress().getStreet());
        address.setCity(entity.getAddress().getCity());
        address.setState(entity.getAddress().getState());

        Customer customer = new Customer();
        customer.setId(entity.getId());
        customer.setName(entity.getName());
        customer.setCpf(entity.getCpf());
        customer.setIsValidCpf(entity.getIsValidCpf());
        customer.setAddress(address);

        return customer;
    }
}
```

---

### ‚úÖ O que faz o `CustomerEntityMapper`?

| M√©todo       | Fun√ß√£o                                                                                  |
| ------------ | --------------------------------------------------------------------------------------- |
| `toEntity()` | Converte um `Customer` (dom√≠nio) em `CustomerEntity` (infra) para **salvar no banco**   |
| `toDomain()` | Converte um `CustomerEntity` (infra) em `Customer` (dom√≠nio) para **usar na aplica√ß√£o** |

> üí° Ele mant√©m o **dom√≠nio independente da tecnologia de persist√™ncia**, seguindo a proposta da arquitetura hexagonal.

---

## ‚úèÔ∏è Parte 4: Criar um teste de integra√ß√£o real (chamando a API)

Em constru√ß√£o

### üìå Pr√≥ximos passos:

7. **Criar o Controller (porta de entrada)**

    - Para expor o endpoint REST e permitir a cria√ß√£o de clientes via HTTP.

---

Se quiser, posso escrever a estrutura da classe `CreateCustomerUseCase` para voc√™ com exemplos. Deseja isso?

https://github.com/DaniloArantesSilva/hexagonal-architecture
